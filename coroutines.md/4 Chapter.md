Составление suspend функций

В этом разделе рассматриваются различные подходы к композиции функций приостановки

1. Последовательный вызов по умолчанию.
Если нам, например, нужно вызвать две функции последовательно, то мы просто так и запишем. Мы используем обычный последовательный вызов, потому что код в сопрограмме, как и в обычном коде, по умолчанию последовательный.

2. Параллельное с использованием async()
Концептуально async() аналогичен launch(). Он запускает отдельную сопрограмму, представляющую собой облегченный поток, который работает одновременно со всеми другими сопрограммами.

Разница в том, что launch() возвращает Job и не несет никакого результирующего значения, тогда как async возвращает Deferred — облегченное неблокирующее будущее, которое представляет собой обещание предоставить результат позже.  

Можно использовать await() для deffered, чтобы получить его окончательный результат, но отложенное также является Job'ом, поэтому при необходимости можно отменить его.

3. Лениво запущенный async()
async() можно сделать ленивой, установив для параметра запуска значение CoroutineStart.LAZY. async(CoroutineStart.LAZY)

Обратите внимание, что если мы просто вызовем await в без предварительного вызова start для отдельных сопрограмм, это приведет к последовательному поведению, поскольку await запускает выполнение сопрограммы и ждет ее завершения, что не является предполагаемым вариантом использования lazy. Вариант использования для async(start = CoroutineStart.LAZY) — это замена стандартной ленивой функции в случаях, когда вычисление значения включает приостановку функций.

4. Асинхронные функции